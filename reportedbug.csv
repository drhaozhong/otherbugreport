gcc++,reported ID,URL,referenced ID,referenced URL,status,component,importance,keyword,version,code sample
,86665,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86665,1876,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=1876,dupl,c++,P3,accepts-invalid,9.0,"namespace Name {
 template <class T> class Point;
}

using Name::Point;

template <class T> class Point {
 public:
 Point() {}
 protected:
 T member;
};

int main(void) {
 Name::Point<double> d;
 return(0);
}"
,86502,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86502,5134,https://bugs.llvm.org/show_bug.cgi?id=5134,dupl,c++,P3,accepts-invalid,9.0,"class Test
{
 friend const int getInt(int inInt = 0);
};"
,86298,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86298,6964,https://bugs.llvm.org/show_bug.cgi?id=6964,dupl,c++,P3,accepts-invalid,8.0.1,"template <typename ,int, int = 9223372036854775807L >
struct as_nview { };

template <typename Sequence, int I0> 
struct as_nview<Sequence, I0> 
{ };"
,86596,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86596,7607,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=7607,dupl,c++,P3,accepts-invalid,9.0,"template<char i> struct A {};

typedef A<255> B;

int main() { return 0; }"
,86185,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86185,9276,https://bugs.llvm.org/show_bug.cgi?id=9276,dupl,c++,P3,accepts-invalid,7.0,"template<typename T>
void f() {
  auto i = T(), j = 0;
}

int main() {
  f<long>();
  f<int>();
}"
,86580,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86580,10618,https://bugs.llvm.org/show_bug.cgi?id=10618,dupl,c++,P3,accepts-invalid,9.0,"struct S { S(const S&, int); S(int); }; S::S(const S& = S(0), int = 0) {}"
,86230,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86230,14500,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=14500,dupl,c++,P3,accepts-invalid,unknown,"#include <vector>
#include <cassert>
#define VERIFY assert
 
struct T { int i; };

int swap_calls;

namespace std
{
 // Should be most specialized.
#if 1
 template<> 
#endif
 inline void 
 swap(vector<T, allocator<T> >&, vector<T, allocator<T> >&) 
 { ++swap_calls; }
}

void test01()
{
 bool test __attribute__((unused)) = true;
 std::vector<T> A;
 std::vector<T> B;
 swap_calls = 0;
 std::swap(A, B);
 VERIFY(1 == swap_calls); // XXX fails
}

void test02()
{
 bool test __attribute__((unused)) = true;
 using namespace std;
 vector<T> A;
 vector<T> B;
 swap_calls = 0;
 swap(A, B);
 VERIFY(1 == swap_calls);
}

int main()
{
 test01();
 test02();
 return 0;
}"
,86600,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86600,24030,https://bugs.llvm.org/show_bug.cgi?id=24030,dupl,c++,P3,accepts-invalid,9.0,"namespace X { class A; }

namespace Y { using X::A; class A {}; }"
,86187,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86187,25357,https://bugs.llvm.org/show_bug.cgi?id=25357,dupl,c++,P3,accepts-invalid,9.0,"using Y = int[10];

int main() {
    (Y { })[0] = 1;
}"
,86235,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86235,37719,https://bugs.llvm.org/show_bug.cgi?id=37719,dupl,c++,P3,accepts-invalid,5.1.0,"template< int mydim, typename Traits >
class BasicGeometry
{
typedef int some_type_t;
};

template<class ctype, int mydim, int coorddim>
class MockGeometry : BasicGeometry<mydim, int>{
using typename BasicGeometry<mydim, int>::operator[]; // expected-error {{typename is allowed for identifiers only}}
};

int main() {
   return 0;
}"
,86255,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86255,37850,https://bugs.llvm.org/show_bug.cgi?id=37850,dupl,c++,P3,accepts-invalid,9.0,"class Z {
public:


 Z(int);

private:
 int i;
};
Z::Z(int j=43): i(j){}


int main()
{
 Z zobject=Z();

}"
,86225,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86225,71748,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71748,dupl,c++,P3,accepts-invalid,4.4.0,"struct A
{ 
 virtual ~A () {}
};

struct B : public A
{ 
 virtual ~B () {}
};

template < int > void foo ()
{ 
 B *b = new B;
 b->~A ();
}

int main ()
{ 
 foo < 0 > ();
 return 0;
}
"
,86237,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86237,79184,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79184,dupl,c++,P3,accepts-invalid,4.8.1,"enum { E = 2 };
template <bool> void f(int) {}
template <int> void f() {}

int
main ()
{
 f<1 * 1>();
 f<1 << 1>();
 f<1 ? 3 : 2>();
 f<E>();

 f<1 * 1>(0);
 f<1 << 1>(0);
 f<1 ? 3 : 2>(0);
 f<E>(0);
}"
,86250,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86250,2189,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=2189,dupl,c++,P3,accepts-invalid,unknown,"//#include <iostream>
//using namespace std;
class Z {
public:
 // gcc version egcs-2.91.66 19990314/Linux (egcs-1.1.2 release) allows to
 // write Z(int) while gcc version 2.97 20010205 wants Z(int j=43)
 Z(int);
 //void print ();
private:
 int i;
};
Z::Z(int j=43): i(j){}
//void Z::print(void){ cout << ""Z : i= "" << i << "".\n"";}

int main()
{
 Z zobject=Z();
 //zobject.print();
}"
,86499,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86499,18128,https://bugs.llvm.org/show_bug.cgi?id=18128,fixed,c++,P3,accepts-invalid,8.1.0, auto l = [=]{};
,86249,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86249,1876,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=1876,new,c++,P3,accepts-invalid,unknown,"namespace Name {
 template <class T> class Point;
}

using Name::Point;

template <class T> class Point {
 public:
 Point() {}
 protected:
 T member;
};

int main(void) {
 Name::Point<double> d;
 return(0);
}
"
,86563,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86563,6527,https://bugs.llvm.org/show_bug.cgi?id=6527,new,c++,P3,accepts-invalid,9.0,"struct T;

template <typename U>
void f()
{
 try
 {}
 catch(T const &)
 {}
}

struct T
{};

int main()
{
 f<int>();
 return 0;
}"
,86633,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86633,9546,https://bugs.llvm.org/show_bug.cgi?id=9546,new,c++,P3,accepts-invalid,9.0,int x = reinterpret_cast<const int&&>(1.0f);
,86601,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86601,9834,https://bugs.llvm.org/show_bug.cgi?id=9834,new,c++,P3,accepts-invalid,9.0," struct S {
 class T friend;
 unsigned friend char;
 };"
,86652,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86652,13447,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=13447,new,c++,P3,accepts-invalid,9.0,"class C { 
public: 
 template <typename i> 
 int (*f())() const; 
};"
,86561,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86561,14265,https://bugs.llvm.org/show_bug.cgi?id=14265,new,c++,P3,accepts-invalid,9.0,"struct S { int f(), g() = delete; };"
,86581,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86581,14503,https://bugs.llvm.org/show_bug.cgi?id=14503,new,c++,P3,accepts-invalid,9.0,"template<typename> struct V {
 union { int n; struct { int x,y; }; };

 constexpr V() : x(0) {} 
}; 
constexpr V<int> v;"
,86602,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86602,15842,https://bugs.llvm.org/show_bug.cgi?id=15842,new,c++,P3,accepts-invalid,9.0,"void f();
void f(int);
bool b = noexcept(f);"
,86233,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86233,16021,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=16021,new,c++,P3,accepts-invalid,unknown," #define _GLIBCXX_DEBUG
 #include <vector>

 struct T { int i; };

 int swap_calls;

 namespace std
 {
 template<>
 void
 vector<T, allocator<T> >::swap(vector<T, allocator<T> >&)
 { ++swap_calls; }
 }

 // Should use vector specialization for swap.
 int main()
 {
 std::vector<T> A;
 std::vector<T> B;
 swap_calls = 0;
 std::swap(A, B);
 return swap_calls;
 }"
,86500,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86500,20991,https://bugs.llvm.org/show_bug.cgi?id=20991,new,c++,P3,accepts-invalid,8.1.0,"struct S { struct T {}; };
::decltype(S())::T st;"
,86238,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86238,37720,https://bugs.llvm.org/show_bug.cgi?id=37720,new,c++,P3,accepts-invalid,unknown,
,86228,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86228,45278,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=45278,new,c++,P3,accepts-invalid,unknown,"extern void* p;
int main() { return ( p<0 ? 1 : 0 ); }

clang++ rejects it with an error message:
error: ordered comparison between pointer and zero ('void *' and 'int')
    int main() { return ( p<0 ? 1 : 0 ); }"
,86234,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86234,62255,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62255,new,c++,P3,accepts-invalid,unknown,"template <class T> struct B;

template <bool b>
struct C { };

template <class T>
struct A: C<B<A<T>>::value>
{
 typedef T Type;
};

template<class T>
struct B
{
 template<typename X> static int check(typename X::Type*);
 template<typename> static char check(...);
 static const bool value = (sizeof(check<T>(0)) == sizeof(int));
};

int main()
{
 return B<A<int>>::value;
}
"
,86181,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86181,5966,https://bugs.llvm.org/show_bug.cgi?id=5966,suspended,c++,P3,accepts-invalid,8.1.0,"extern ""C"" void abort();
static int i;
int *p = &i;
int main()
{ 
 int i;
 { 
 extern int i;
 i = 1;
 *p = 2;
 if (i == 2)
 abort ();
 }
 return 0;
}"
,86191,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86191,8427,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8427,suspended,c++,P3,accepts-invalid,unknown,"template<int i> struct g {};

template<int i, int j> void f(g<i/j>) { }
template<int i, int j> void f(g<j>) { } 

int main()
{
  f<4,2>(g<4/2>());
}"
,86583,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86583,53903,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53903,suspended,c++,P3,accepts-invalid,9.0,"struct T {
    T() noexcept(false) { }
    ~T() noexcept(false) { }
};

struct A
{
    A() noexcept = default;
    ~A() noexcept = default;

    T t;
};"
,86253,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86253,37843,https://bugs.llvm.org/show_bug.cgi?id=37843,unconfirmed,c++,P3,accepts-invalid,unknown,"int main(int argc, char** argv)
{
 int x[1][argc];
 
 [&x](int i)
 {
 x[0][i] = 0;
 }(5);

 return 0;
}"
,86299,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86299,7385,https://bugs.llvm.org/show_bug.cgi?id=7385,invalid,c++,P3,accepts-invalid,9.0,"template< typename > struct has_xxx0
{
  template< typename > struct has_xxx0_introspect
  {
    template< typename > struct has_xxx0_substitute ;
    template< typename V > 
    int int00( has_xxx0_substitute < typename V::template xxx< > > = 0 );
  };
  static const int value = has_xxx0_introspect<int>::value;
  typedef int type;
};

has_xxx0<int>::type t;"
,86303,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86303,7055,https://bugs.llvm.org/show_bug.cgi?id=7055,unconfirmed,c++,P3,accepts-invalid,9.0,"struct auto_ptr {
 struct auto_ptr_ref { };

 auto_ptr(auto_ptr&);
 auto_ptr(auto_ptr_ref);

 operator auto_ptr_ref();
};

auto_ptr foo();

struct X {
 X(auto_ptr);
};

struct Y {
 Y(X);
};

Y f(foo());"
,86501,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86501,28023,https://bugs.llvm.org/show_bug.cgi?id=28023,new,c++,P3,accepts-invalid,8.1.0,"template < int V >
struct A
{ 
 struct B
 { 
 template < int > friend struct V; 
 };
};

A < 0 >::B a;"
conflict,86564,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86564,4594,https://bugs.llvm.org/show_bug.cgi?id=4594,new,c++,P3,accepts-invalid,9.0," struct foo {
 static bool const value = false;
 };

 int main() {
 int v(int(foo::value));
 }
"
,86565,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86565,21332,https://bugs.llvm.org/show_bug.cgi?id=21332,unconfirmed,c++,P3,accepts-invalid,9.0,"template<typename T> void f() {
 struct S { void g(int n = T::error) noexcept(T::error); };
}
template void f<int>();"
,86577,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86577,7209,https://bugs.llvm.org/show_bug.cgi?id=7209,unconfirmed,c++,P3,accepts-invalid,9.0," #include <iostream>

 namespace N {
 struct X { };
 }
 using namespace N;

 template<typename T>
 void log(const T& t) {
 std::clog << t;
 } 

 std::ostream &operator<<(std::ostream&, const X& x);

 template void log(const X&);"
,86579,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86579,30782,https://bugs.llvm.org/show_bug.cgi?id=30782,unconfirmed,c++,P3,accepts-invalid,9.0,"template <typename T>
bool greater()
{
 T p = nullptr;
 return p > nullptr;
}

int main ()
{
 greater<void *>();
}"
,86634,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86634,6031,https://bugs.llvm.org/show_bug.cgi?id=6031,invalid,c++,P3,accepts-invalid,9.0,"template <class TT> struct ForwardIterator {
    Convertible<typename ForwardIterator::iterator_category> a;
    class iterator_category { ... }; // or maybe a typedef
  };"
,85460,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85460,7051,https://bugs.llvm.org/show_bug.cgi?id=7051,new,c++,P3,diagnostic,7.3.1,"enum _Ios_Iostate
{
};

template<typename>
struct basic_istream
{
  struct sentry
  {
    sentry(basic_istream& )
    {
      _Ios_Iostate __err ;
      __err |=1;
    }
  };
};"
,86709,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86709,4319,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=4319,new,c++,P3,documentation,9.0,"typedef unsigned char __u8;
__u8 short slot_tablelen;"
,86718,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86718,86528,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86528,dupl,middle-end,P3,ice-on-valid-code,9.0,"void __attribute__((noinline, noclone))
test(char *data, __SIZE_TYPE__ len)
{
 static char const appended[] = ""/./"";
 char *buf = __builtin_alloca (len + sizeof appended);
 __builtin_memcpy (buf, data, len);
 __builtin_strcpy (buf + len, &appended[data[len - 1] == '/']);
 if (__builtin_strcmp(buf, ""test1234/./""))
 __builtin_abort();
}

int
main()
{
 char *arg = ""test1234/"";
 test(arg, __builtin_strlen(arg));
 return 0;
}"
,86558,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86558,50436,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=50436,new,c++,P3,ice-on-valid-code,9.0,"template <bool> struct VI {};
template <typename T>
struct IP
{
 static const bool r = IP<T>::r;
};
template <typename T> struct V
{
 VI<IP<T>::r> vi;
};
struct X;
struct Y
{
 V<X> v;
};"
,86594,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86594,81236,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81236,new,c++,P3,ice-on-valid-code,9.0,"#include <tuple>

template <typename T, T... S, typename F>
constexpr void for_sequence(std::integer_sequence<T, S...>, F&& f) {
	using unpack_t = int[];
	(void)unpack_t{(static_cast<void>(f(std::integral_constant<T, S>{})), 0)..., 0};
}

template<typename Tup>
struct MyType {
	void crash() {
		for_sequence(std::make_index_sequence<std::tuple_size<Tup>::value>{}, [&](auto i){
			make_crash<i>();
		});
	}
	
	template<int i>
	void make_crash() {}
};

int main() {
	MyType<std::tuple<int, double, double, const char*>> test;
	
	test.crash();
}"
,86478,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86478,19878,https://bugs.llvm.org/show_bug.cgi?id=19878,dupl,c++,P3,ice-on-valid-code,8.1.0,"template<class ...T>
struct X
{};

template<class ...T>
void foo(X<T, T...>... a);

void test()
{
 foo(X<int, int, double>(), X<double, int, double>());
}"
,86715,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86715,56344,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56344,unconfirmed,middle-end,P3,ice-on-valid-code,9.0,"#define COLS 24000L

struct Matrix {
  float data[COLS * COLS];
};

float mulv(float A[], float B[], int i, int j)
{
  float result = 0.0;
  { int k; for (k = 0; k < COLS; ++k)
             result += A[i*COLS + k] * B[j + k*COLS];
  }
  return result;
}

struct Matrix mulm(struct Matrix A, struct Matrix B)
{
  struct Matrix result;

#define IJ(M) (M[i*COLS + j])

  { int i, j; for (i = 0; i < COLS; ++i)
                for (j = 0; j < COLS; ++j)
                  IJ(result.data) = mulv(A.data, B.data, i, j);
  }
  return result;
}

int main(int argc, char* argv[])
{
  struct Matrix m1, m2, result;

  result = mulm(m1, m2);
  return result.data[argc];
}"
,86182,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86182,10531,https://bugs.llvm.org/show_bug.cgi?id=10531,fixed,c++,P2,"ice-on-valid-code, rejects-valid",8.1.1,"#include <stdio.h>

template<typename T> static char const * f(T *t) {
 T u(*t);
 u.x = ""hello world"";
 printf(""%s\n"", u.x);
 return ""initialized"";
}

int main() {
 union { char const *x = f(this); };
 printf(""%s\n"", x);
}
"
,86208,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86208,3698,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=3698,fixed,c++,P3,link-failure,8.1.1,"class X {
public:
 int i;
};

inline const int& OHashKey(const X& x) {
 return x.i;
}

int main() {
 extern const int& OHashKey(const X& x);
 X x;
 return OHashKey(x);
}"
,86476,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86476,21437,https://bugs.llvm.org/show_bug.cgi?id=21437,fixed,c++,P3,rejects-valid,8.1.0,"template <typename T>
struct A {
 void f() noexcept(noexcept(m.f())) {
 m.f();
 }
 T m;
};
struct B { void f(); };
int main() {
 A<B> a;
 a.f();
}"
,86307,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86307,7863,https://bugs.llvm.org/show_bug.cgi?id=7863,dupl,c++,P3,rejects-valid,8.0.1,"template<class X> void ook();
typedef int (*tf)();
typedef void (*ookf)();
tf r1;
ookf r2, r3;
bool r4, r5;
bool c1;
ookf c2, c3;
void a() {
 // rejected
 r1 = reinterpret_cast<tf>(ook<int>);
 r2 = 1 ? ook<int> : 0;
 r3 = *ook<int>;
 r4 = 1 || ook<int>;
 r5 = ook<int> == ook<int>;

 // crash in codegen
 c1 = !ook<int>;

 // crash in sema
 c2 = 1 ? ook<int> : ook<int>;
 c3 = (0, ook<int>);
}"
,86310,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86310,8905,https://bugs.llvm.org/show_bug.cgi?id=8905,dupl,c++,P3,rejects-valid,8.0.1,"template<char C1, char C2>
struct X;

template<int C1>
struct X<C1, C1>;"
,86474,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86474,9359,https://bugs.llvm.org/show_bug.cgi?id=9359,dupl,c++,P3,rejects-valid,8.1.0,"namespace PR5820 {
struct Base {};
struct D1 : public Base {};
struct D2 : public Base {};

struct Derived : public D1, public D2 {
 void Inner() {
 }
};
}

template<typename T>
struct BaseT {
 int Member;
};

template<typename T> struct Derived1T : BaseT<T> { };
template<typename T> struct Derived2T : BaseT<T> { };

template<typename T>
struct DerivedT : public Derived1T<T>, public Derived2T<T> {
 void Inner();
};

template<typename T>
void Test(DerivedT<T> d) {
 d.template Derived2T<T>::Member = 17;
}

template void Test(DerivedT<int>);"
,86180,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86180,9518,https://bugs.llvm.org/show_bug.cgi?id=9518,dupl,c++,P3,rejects-valid,7.3.1,"template<typename T> 
struct provide {
  friend T f() { return T(); }
};

void g() {
  void f();
  provide<void> p;
  f();
}

int main() {
  g();
}"
,86305,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86305,30361,https://bugs.llvm.org/show_bug.cgi?id=30361,dupl,c++,P3,rejects-valid,3.3.1,"template <typename T>
struct
C1
{
 ~C1() {}
 void foo1();
};

template<typename T>
void C1<T>::foo1() {
 C1::~C1();
}

void foo1() {
 C1<int> x;
 x.foo1();
}"
,86207,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86207,67371,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=67371,dupl,c++,P3,rejects-valid,7.0,"constexpr int f(){
 if(true) return 0;
 throw 0;
}

int main(){
 constexpr auto i = f();
}"
,86184,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86184,7726,https://bugs.llvm.org/show_bug.cgi?id=7726,fixed,c++,P3,rejects-valid,unknown,"#include <stdio.h>

int main(int argc, char **argv) {
	printf(""%p\n"", (void *)0xdeadbeef ? : (void *)0xaaaaaa);
	return 0;
}"
,86302,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86302,9208,https://bugs.llvm.org/show_bug.cgi?id=9208,new,c++,P3,rejects-valid,8.0.1,"template<typename T>
void f();

int main() {
 f<int> != 0;
}"
,86431,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86431,9989,https://bugs.llvm.org/show_bug.cgi?id=9989,new,c++,P3,rejects-valid,8.1.0,"struct A { 
 static int const B = sizeof B; 
 };"
,85461,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=85461,9999,https://bugs.llvm.org/show_bug.cgi?id=9999,new,c++,P3,rejects-valid,7.3.1,"template<unsigned int v>
class bitWidthHolding {
public:
    /** width is the number of bits occupied by the template parameter v
        */
    static const
    unsigned int width = (v == 0 ? 0 : bitWidthHolding<(v >> 1)>::width + 1);
};"
,86183,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86183,10044,https://bugs.llvm.org/show_bug.cgi?id=10044,new,c++,P3,rejects-valid,8.1.0,"template<typename T>
struct A {
 enum class B {
 X = T::value
 };
};

int main() {
 A<int> a;
}"
,86598,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86598,12717,https://bugs.llvm.org/show_bug.cgi?id=12717,new,c++,P3,rejects-valid,9.0,"#define PREFIX(x) foo ## x
void f() {
 int PREFIX(1p);
 int PREFIX(2p) = PREFIX(1p+5); // incorrect error: foo1p+5 is not a pp-token
}"
,86498,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86498,16314,https://bugs.llvm.org/show_bug.cgi?id=16314,new,c++,P3,rejects-valid,8.1.0," void f(char*);
 int &f(...);
 int &r = f(""foo"");"
,86475,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86475,17052,https://bugs.llvm.org/show_bug.cgi?id=17052,new,c++,P3,rejects-valid,8.1.0,"struct X
{
 int i_;
 bool b_;

 int& test() {return b_ ? i_ : throw 1;}
};
"
,86254,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86254,33786,https://bugs.llvm.org/show_bug.cgi?id=37844,new,c++,P3,rejects-valid,unknown,"namespace N {
 extern ""C"" {
 extern const int foobar;
 const int foobar = 1;
 struct S { static const int foobar; };
 const int S::foobar = 2;
 }
}
int main () { return !(N::foobar + 1 == N::S::foobar); }"
,86251,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86251,37829,https://bugs.llvm.org/show_bug.cgi?id=37829,new,c++,P3,rejects-valid,unknown,"#include <utility>
#include <iostream>

using namespace std;

template <typename _T, _T _V>
	void foo()
	{
		cout << __PRETTY_FUNCTION__ << endl;
	}

int a = 0;

int b() { cout << __PRETTY_FUNCTION__ << endl; }

int main()
{
	foo<int, 9>();
	foo<int (), b>();
}"
,86503,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86503,44175,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=44175,new,c++,P3,rejects-valid,8.1.0,"template< bool c, class T >
struct enable_if {
    typedef T type;
};

template< class T >
struct enable_if< true, T > {};

template< class F, int n >
void
ft( F f, typename enable_if< n == 0, int >::type ) {}

template< class F, int n >
typeof( ft< F, n-1 >( F(), 0 ) )
ft( F f, typename enable_if< n != 0, int >::type ) {}

int main() {
    ft< struct a*, 2 >( 0, 0 );
}"
,86252,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86252,37833,https://bugs.llvm.org/show_bug.cgi?id=37833,new,c++,P3,rejects-valid,unknown,"template<typename T>
struct S{};

struct A
{
 virtual void f() = 0;
};

int main()
{
 S<A(int)> s;
}
"
,86193,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86193,44753,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=44753,suspended,c++,P3,rejects-valid,8.1.0,"template <class T>
struct identity
{
 typedef T type;
};

template <class T, typename T::type A>
struct foo {};

template <class T, T A>
struct foo<identity<T>, A> {};

int main()
{
 foo<identity<int>,0> bar; // error here
}"
,86430,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86430,7708,https://bugs.llvm.org/show_bug.cgi?id=7708,unconfirmed,c++,P3,rejects-valid,9.0,"template<typename T>
struct Const { typedef void type; };

template<typename T>
void f(T, typename Const<T>::type*) { } // T1

template<typename T>
void f(T, void *) { } // T2

int main() { void *p = 0; f(0, p); }"
,86192,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86192,70377,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70377,dupl,c++,P3,rejects-valid ,7.0,"#include <array>
#include <cstddef>
#include <exception>

template <std::size_t N>
constexpr size_t simple_find(const std::array<int, N> &arg_array,
 const int &arg_value
 ) {
 for (size_t ctr = 0; ctr != N; ++ctr) {
 if ( arg_array[ ctr ] == arg_value ) {
 return ctr;
 }
 }
 throw std::out_of_range( """" );
}

static constexpr std::array<int, 3> some_ints { { 10, 11 } };

static_assert( simple_find( some_ints, 10 ) == static_cast<size_t>( 0 ), """" );
static_assert( simple_find( some_ints, 11 ) == static_cast<size_t>( 1 ), """" );

int main() { }"
,86385,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86385,35039,https://bugs.llvm.org/show_bug.cgi?id=35039,new,c++,P3,wrong-code,9.0,"struct A {
 int* a;
 A(int a) : a(new int(a)) {}
 ~A() { delete a; }
 
 A(const A&) = delete;
 A(A&& other) { a = other.a; other.a = 0; };
 
 operator bool() { return true; }
 int operator*() { return *a; }
};

static A makeA(int x) { return A(x); }

int main() {
 A c = makeA(42) ?: makeA(-1);
 return *c;
}"
,86719,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86719,201,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=201,dupl,c,P3,,9.0,"int main(void)
{
 const int nFOO = 1;
 int nFoo = 0;

 switch(nFoo){
 case nFOO:
 exit(1);
 }
 exit(0);
}"
,86074,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86074,20335,https://bugs.llvm.org/show_bug.cgi?id=20335,invalid,c++,P3,,7.3.1,"#include <string>

template <typename T>
struct SimpleAllocator
{
    template <typename U> friend struct SimpleAllocator;

    using value_type = T;
    using pointer = T *;

    struct rebind { template <typename U> using other = SimpleAllocator<U>; };

    using propagate_on_container_copy_assignment = std::true_type;
    using propagate_on_container_move_assignment = std::true_type;
    using propagate_on_container_swap = std::true_type;

    explicit SimpleAllocator(void * p) : state(p) {}

    template <typename U>
    SimpleAllocator(SimpleAllocator<U> const & rhs) : state(rhs.state) {}

    pointer allocate(std::size_t n)
    {
        return static_cast<pointer>(::operator new(sizeof(T) * n));
    }

    void deallocate(pointer p, std::size_t)
    {
        ::operator delete(p);
    }

    template <typename U, typename V>
    friend bool operator==(SimpleAllocator<U> const & lhs, SimpleAllocator<V> const & rhs)
    {
        return lhs.state == rhs.state;
    }

    template <typename U, typename V>
    friend bool operator!=(SimpleAllocator<U> const & lhs, SimpleAllocator<V> const & rhs)
    {
        return lhs.state != rhs.state;
    }

private:
    void * state;
};

using astring = std::basic_string<char, std::char_traits<char>, SimpleAllocator<char>>;

int main()
{
    int x, y;

    SimpleAllocator<void> a(&x), b(&y);

    astring s(""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", a);
    astring t(std::move(s), b);
}
#include <string>

template <typename T>
struct SimpleAllocator
{
    template <typename U> friend struct SimpleAllocator;

    using value_type = T;
    using pointer = T *;

    struct rebind { template <typename U> using other = SimpleAllocator<U>; };

    using propagate_on_container_copy_assignment = std::true_type;
    using propagate_on_container_move_assignment = std::true_type;
    using propagate_on_container_swap = std::true_type;

    explicit SimpleAllocator(void * p) : state(p) {}

    template <typename U>
    SimpleAllocator(SimpleAllocator<U> const & rhs) : state(rhs.state) {}

    pointer allocate(std::size_t n)
    {
        return static_cast<pointer>(::operator new(sizeof(T) * n));
    }

    void deallocate(pointer p, std::size_t)
    {
        ::operator delete(p);
    }

    template <typename U, typename V>
    friend bool operator==(SimpleAllocator<U> const & lhs, SimpleAllocator<V> const & rhs)
    {
        return lhs.state == rhs.state;
    }

    template <typename U, typename V>
    friend bool operator!=(SimpleAllocator<U> const & lhs, SimpleAllocator<V> const & rhs)
    {
        return lhs.state != rhs.state;
    }

private:
    void * state;
};

using astring = std::basic_string<char, std::char_traits<char>, SimpleAllocator<char>>;

int main()
{
    int x, y;

    SimpleAllocator<void> a(&x), b(&y);

    astring s(""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", a);
    astring t(std::move(s), b);
}
"
,86186,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86186,20092,https://bugs.llvm.org/show_bug.cgi?id=20092,invalid,c++,P3,,unknown," #include <tuple>
 #include <utility>

 namespace foo {
 struct bar { bool operator==(bar) const { return true; } };

 template <std::size_t I>
 struct hard_error { static_assert(I > 0, """"); using type = void; };

 template <std::size_t I, typename T>
 typename hard_error<I>::type get(T) {}
 }

 int main()
 {
 std::tuple<foo::bar, int> t1, t2;
 t1 == t2; // error: static_assert failed """"
 // note: in instantiation of template class 'foo::hard_error<0>'
 // note: while substituting explicitly-specified template arguments into function template 'get' 
 }"
,86226,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86226,77914,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77914,invalid,c++,P3,,unknown,"int main() {
 auto l = []<typename>(){};
 l.operator()<void>();
 }"
,86227,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86227,39131,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=39131,invalid,c++,P3,,unknown,"#include <typeinfo>
int main() {
 typeid( 0.dd );
}"
,86300,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86300,7388,https://bugs.llvm.org/show_bug.cgi?id=7388,invalid,c++,P3,,8.0.1,"#ifndef __clang__
typedef bool _Bool;
#endif
template<class _Iter>  struct iterator_traits  {
};
template<> struct iterator_traits<_Bool>  {
};"
,86301,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86301,7079,https://bugs.llvm.org/show_bug.cgi?id=7079,invalid,c++,P3,,8.0.1,"template<typename T>
struct X1 {
 static void member() { T* x = 1; }
};

template<void(*)()> struct instantiate { };

template<typename T>
struct X2 {
 typedef instantiate<&X1<int>::member> i;
};"
,86306,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86306,22043,https://bugs.llvm.org/show_bug.cgi?id=22043,invalid,c++,P3,,8.0.1,"typedef _Atomic(int) A;
A a = A();"
,86477,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86477,16204,https://bugs.llvm.org/show_bug.cgi?id=16204,invalid,c++,P3,,8.1.0,"typedef __attribute__((ext_vector_type(4))) int vi4;
const int &r = vi4(1).x;"
,86562,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86562,16353,https://bugs.llvm.org/show_bug.cgi?id=16353,invalid,c++,P3,,9.0,"struct Foo {
 Foo() {}
 Foo(const Foo&) {}
};

void f(...);

void g() {
 Foo foo;
 f(foo);
 void (*fp)(...) = f;
 fp(foo);
}"
,86578,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86578,22042,https://bugs.llvm.org/show_bug.cgi?id=22042,invalid,c++,P3,,9.0,"template <typename T> void Fun(T A) {
 typedef int __attribute__((__aligned__(A))) T1;
 int k1[__alignof__(T1)];
}"
,86716,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86716,77767,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=77767,invalid,c++,P3,,9.0,"gcc code0.c.cpp 
code0.c.cpp:3:18: error: use of parameter outside function body before '++' token
 f (int a, int b[a++], int c, int d[c++])
                  ^~
code0.c.cpp:3:21: error: expected ')' before ',' token
 f (int a, int b[a++], int c, int d[c++])
   ~                 ^
                     )
code0.c.cpp:3:23: error: expected unqualified-id before 'int'
 f (int a, int b[a++], int c, int d[c++])
                       ^~~
"
,86720,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86720,4777,https://bugs.llvm.org/show_bug.cgi?id=4777,invalid,c,P3,,9.0,"unsigned char foo (unsigned char x)
{
 static volatile unsigned char P1OUT __asm (""0x0021"");
 unsigned char tmp = P1OUT;
 P1OUT = x;
 return tmp;
}"
,86721,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86721,13099,https://bugs.llvm.org/show_bug.cgi?id=13099,invalid,c,P3,,9.0,"void g() {
 __builtin_printf(
 u8R""abcd(%.)abcd""
 ""*d"");
}"
,86729,https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86729,2103,https://bugs.llvm.org/show_bug.cgi?id=2103,invalid,c,P3,,9.0,"void a() {
 typedef float v4sf __attribute__ ((vector_size (16)));
 static v4sf q;
 float* r = &q[0];
}"
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
gcc++,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
code sample,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
clang,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,,,,
,,,,,,,u,,,
